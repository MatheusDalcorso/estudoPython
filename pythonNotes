Notas jogadas sem muita organização, provavelmente não fazem muito sentido para ninguém além de mim. Futuramente pretendo organizar informações no arquivo pythonNotebook.ipynb.

Anotações tiradas de varios lugares, mas a fonte principal é o canal do Corey Schafer no youtube e o livro Python Crash Course, 3rd Edition - A Hands-On, Project-Based do Eric Matthes


comentário em python é criado com #

#cria variável
message = "Hello, world!"


strings podem ser criadas usando aspas duplas ou simples, 
o problema é que se quiser usar simples e usar aspas dentro da string, 
vai precisar usar barra invertida antes dela, tipo assim:
message = 'matheus\'s world'
assim o python sabe que essa aspas no meio da string não fecha a string
o mesmo vale pra uma aspas dupla no meio da string

#message = "matheus's world"
#message = 'matheus\'s world'

#message = 'matheus"s world'
#message = "matheus\"s world"

então a melhor vai depender da situação, use de acordo


To add a tab to your text, use the character combination
\t:
>>> print("Python")
Python
>>> print("\tPython")
	Python

To add a newline in a string, use the character
combination \n:
>>> print("Languages:\nPython\nC\nJavaScript")
Languages:
Python
C
JavaScript

pode combinar os dois também


3 aspas (simples ou duplas, tanto faz) são usadas pra criar uma string de multiplas linhas
message = """Hello, 
world!"""
imprime em duas linhas no terminal
Hello,
world!


lstrip() rstrip() e strip() tiram espaço vazio da esquerda direita e dos dois

.removeprefix() tira o prefixo e devolve o resto da string. Se não acha o prefixo ele só devolve a string original
nostarch_url = 'https://nostarch.com'
nostarch_url.removeprefix('https://')
'nostarch.com'
removesuffix() funciona igual o remove prefix, mas no final da frase

#printa o numero de chars da string
print(len(message))


#printa o char da posição, tratando a string como um array
print(message[0])
tentar acessar uma posição inexistente gera erro, 
diferente do c que deixa e volta um valor alocado naquele espaço de memoria


#printa do espaço 0 até o 5, mas não incluindo o 5
print(message[0:5])
então no caso de "Hello, world!" ele imprime Hello (0, 1, 2, 3 ,4)
se for começar do 0 de uma string, pode suprimir o 0 que ele vai assumir que começa do 0
print(message[:5])
o mesmo vale se quiser ir até o final da string
print(message[7:])
O nome disso é Slicing (https://www.w3schools.com/python/python_strings_slicing.asp , 
https://www.youtube.com/watch?v=ajrtAuDg3yw )


# Print hello world, mas o .lower() deixa tudo em minusculo
print(message.lower())


# Print hello world, mas o .upper() deixa tudo em maiusculo
print(message.upper())


#.count(argumento) conta o numero de vezes que aparece o argumento, no caso de 'Hello', aparece 1
#.count('l') ele printa 3, pois aparecem 3 vezes
print(message.count('l'))


# .find(argumento) vai printar onde começa oque vc quer achar, no caso de Hello ele mostra 0
#no caso de world ele mostra 7
#se o argumento não existir ele mostra -1
#se tiver mais q um ele mostra a posição do primeiro, com l ele mostra 2
print(message.find('l'))
  

#.replace(argumento_a_ser_substituido, argumento_substituto)
# no caso de baixo ele troca world por universe, mas esse retorno precisa ir para uma variavel
# só fazer message.replace('world', 'universe') não funciona para o print abaixo
new_message = message.replace('world', 'universe')
message = message.replace('world', 'universe')
print(message)
print(new_message)


Concatenando strings pra usar em outra frase pode ser feito manualmente assim:

greeting = "Hello"
name = "Matheus"
message = greeting + ', ' + name + '. Welcome!'

mas pra coisas mais compridas é mais facil usar o .format:

messageFormat = '{}, {}. Welcome!'.format(greeting, name)

{} substitui variáveis, que depois são passadas no .format como argumentos.
pra python 3.6 ou acima pode ser usado F-strings, que é ainda mais simples

messageFString = f'{greeting}, {name}. Welcome!'

com ela a variavel é colocada dentro das chaves, facilitando a visualização. 
O .format deixa de existir, agora é colocado um f antes de começar a string
Outra utilidade dela é a possibilidade de encrever código dentro do espaço reservado da variavel

messageFString = f'{greeting}, {name.upper()}. Welcome!'

aqui foi usado um upper dentro, para deixar o nome em maiusculo




*************ALGO MUITO UTIL PARA SE LEMBRAR*************
dir(object) retorna todas as propriedades e métodos do objeto especificado, sem os valores
então usando assim print(dir(message)) o terminal imprime isso:
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
que são os metodos que podemos usar nesse objeto string. Dá pra notar alguns que já usei
como o upper, lower, count, len e etc
https://www.w3schools.com/python/ref_func_dir.asp

ele não dá nenhuma informação sobr os metodos, para isso a gente pode usar o help():
help(str)
printa:
Help on class str in module builtins:

class str(object)
 |  str(object='') -> str
 |  str(bytes_or_buffer[, encoding[, errors]]) -> str
 |
 |  Create a new string object from the given object. If encoding or
 |  errors is specified, then the object must expose a data buffer
 |  that will be decoded using the given encoding and error handler.
 |  Otherwise, returns the result of object.__str__() (if defined)
 |  or repr(object).
 |  encoding defaults to 'utf-8'.
 |  errors defaults to 'strict'.
 |
 |  Methods defined here:
 |
 |  __add__(self, value, /)
 |      Return self+value.
 |
 ...
 |  lower(self, /)
 |      Return a copy of the string converted to lowercase.
 ...
pra ver a documentação relacionada com strings
https://www.geeksforgeeks.org/python/help-function-in-python/

pode ser passado com um metodo especifico dentro, help(str.upper) printa:
Help on method_descriptor:

upper(self, /) unbound builtins.str method
    Return a copy of the string converted to uppercase.
*********************************************************




type() é usado para descobrir o tipo do objeto

number = 1.2
print(type(number))

printa <class 'float'>

number = 1
printa <class 'int'>

podemos atribuir vários valores ao mesmo tempo para variáveis
isso: x, y, z = 1, 2, 3
é igual:
x=1
y=2
z=3


python não possui variáveis do tipo constante, os programadores usam letras maiusculas para indicar uma variável que deve ser tratada como constante (ex: MAX_CONNECTIONS = 5000)



pode ser usado underscore em numeros para ficar mais fácil de contar as casas em numeros muito grandes

universe_age = 14_000_000_000
quando printa ele só escreve os numeros, ele só ajuda o programador a ler o código facilmente
print(universe_age) ->14000000000
ele também não interfere nas operações nem no tipo das variaveis
x = 1_0 + 5
print(type(x) ,x) -> <class 'int'> 15


# Arithmetic Operators:
# Addition:       3 + 2
# Subtraction:    3 - 2
# Multiplication: 3 * 2
# Division:       3 / 2
# Floor Division: 3 // 2
# Exponent:       3 ** 2 (= 3²)
# Modulus:        3 % 2

# Floor division is a division operation that returns the largest integer 
# that is less than or equal to the result of the division.
# In Python, it is denoted by the double forward slash '//'. https://www.geeksforgeeks.org/python/floor-division-in-python/#what-is-floor-division


# Comparisons:
# Equal:            3 == 2
# Not Equal:        3 != 2
# Greater Than:     3 > 2
# Less Than:        3 < 2
# Greater or Equal: 3 >= 2
# Less or Equal:    3 <= 2


num += 1 essa abreviação funciona para todas operações

Absolute value of an integer(funciona com float também)
abs(numero)
print(abs(-3)) -> 3
basicamente tira o sinal negativo do numero


round(numero, quantasCasasQuerArredondarPara)
segundo argumento é opcional
print(round(3.2)) -> 3
print(round(3.5)) -> 4
print(round(3.59, 1)) -> 3.6
print(round(3.1415, 2)) -> 3.14


num1 = '100'
num2 = '200'

print(num1 + num2): -> 100200
pq são strings, então pra somar eles precisa fazer casting (https://www.w3schools.com/python/python_casting.asp)

num1 = int(num1)
num2 = int(num2)

print(num1 + num2): -> 300


courses = ['history', 'math', 'phisics', 'compSci']
#print(len(courses)) -> 4

print(courses[0]) -> history

também pode ser acessado com numero negativo, ai começa pelo final da lista
print(courses[-1]) -> compSci
print(courses[-4]) -> history
-5 no caso da erro pois é maior que a lista

é pratico pra pegar o ultimo item da lista, pois mesmo q adicionem coisas novas o -1 sempre será o ultimo item

print(courses[0:2]) -> ['history', 'math']  ([0 , 1])
segue a mesma regra da linha 42, começa do 0 e vai até o 2, mas não inclui o 2
courses[:2] assume q quer começar do 0
courses[0:] assume q quer ir até o final
o nome disso é slicing


courses.append('art') adiciona o valor 'art' no final da lista courses
->['history', 'math', 'phisics', 'compSci', 'art']

insert leva 2 argumentos, o index onde o valor será inserido e o valor a ser inserido
courses.insert(0,'portuguese')
->['portuguese', 'history', 'math', 'phisics', 'compSci']

o insert não funciona direito pra adicionar outra lista em uma existente, se fizer ele literalmente coloca 1 lista dentro da outra
o append também não funciona, ele também coloca uma lista dentro da outra
courses_2 = ['geography', 'physicalEd']
courses.insert(0,courses_2)
-> [['geography', 'physicalEd'], 'portuguese', 'history', 'math', 'phisics', 'compSci', 'art']
agora a courses[0] -> ['geography', 'physicalEd']
pra adicionar os valores de uma lista para outra é usado o extend
courses.extend(courses_2) só leva um argumento, que é a lista que vai ser adicionada a outra
-> ['portuguese', 'history', 'math', 'phisics', 'compSci', 'art', 'geography', 'physicalEd']


# .remove(valor) é usado para remover o valor da lista
courses.remove('math')
#.pop() é usado para remover o ultimo valor da lista. Uma coisa legal dele é que ele retorna o valor que removeu da lista, então você pode pegar esse valor para usar em outra coisa
popped = courses.pop()

print(popped) -> physicalEd


.reverse() inverte as posiçoes de uma lista. Primeiro vira ultimo, ultimo vira primeiro e etc
courses.reverse() -> ['geography', 'art', 'compSci', 'phisics', 'history', 'portuguese']

.sort() organiza em alfabética, ou do menor pro maior se for numeros. Ele aceita o argumento reverse, que arruma do maior pro menor .sort(reverse=True)
numList = [50, 84, 37, 5, 0]
numList.sort()
print(numList) -> [0, 5, 37, 50, 84]


pra obter a lista organiza sem mudar a ordem original da lista pode ser usado a função sorted()
ela retorna a lista organizada sem mexer com a original, como o valor é retornado ele pode ser guardado em uma variavel
(numListOrganizada = sorted(numList))
numList = [50, 84, 37, 5, 0]

print(numList) -> [50, 84, 37, 5, 0]
print(sorted(numList)) ->  [0, 5, 37, 50, 84]


min() seleciona o menor numero ou primeira string em ordem alfabetica

max() faz a mesma coisa so q ao contrário. O maior ou o ultimo na ordem alfabetica

sum() soma os numeros


pra achar o index de um valor em uma lista, podemos usar .index(valor) na lista
courses.index('compSci') por exemplo, vai printar 3
(['portuguese', 'history', 'phisics', 'compSci', 'art', 'geography', 'physicalEd'])


pra checar se um valor existe em uma lista e receber um bool como retorno usamos o operador 'in'
print('art' in courses) -> True


#loop pra printar todos os itens da lista courses
for course in courses:
    print(course)
-> portuguese
   history
   phisics...


pra pegar o index no loop, usamos enumerate()
for index, course in enumerate(courses):
    print(index, course)
-> 0 portuguese
   1 history
   2 phisics
   3 compSci...

da pra começar em um index especifico usando o enumerate(variavel, start=x)
for index, course in enumerate(courses, start=3):
    print(index, course)
-> 3 portuguese
   4 history
   5 phisics...



pra transormar uma lista em string usamos um metodo da string chamado .join
courses_str = ', '.join(courses)
print(courses_str) -> portuguese, history, phisics, compSci, art, geography, physicalEd

com ' - '-> portuguese - history - phisics - compSci - art - geography - physicalEd

pra fazero caminho reverso disso e transormar a string em lista usamos .split separando em uma parte especifica da string
new_list = courses_str.split(' - ')

print(new_list) -> ['portuguese', 'history', 'phisics', 'compSci', 'art', 'geography', 'physicalEd']




tuples são parecidas com listas, mas com uma diferença importante, tuples são imutaveis enquanto listas são mutaveis
# Mutable
list_1 = ['History', 'Math', 'Physics', 'CompSci']
list_2 = list_1

print(list_1)
print(list_2)

# list_1[0] = 'Art'

# print(list_1)
# print(list_2)

no caso de cima, mudando o valor da lista 1, ele muda da 2 também. Não tenho certeza, mas acho q é pq a 2 só aponta pro mesmo endereço de memória q a 1
seja oq for eu não gostei q funciona assim(explicação do chatgpt abaixo)

# Immutable
# tuple_1 = ('History', 'Math', 'Physics', 'CompSci')
# tuple_2 = tuple_1

# print(tuple_1)
# print(tuple_2)

# tuple_1[0] = 'Art'

# print(tuple_1)
# print(tuple_2)


listas e tuples funcionam iguais na hora de usar um for pra acessar conteudo, acessar um index especifico, etc.
Mas tuple não consegue receber uma mudança de valor (TypeError: 'tuple' object does not support item assignment)
então se precisar mudar valor de algo, use lista. Se só for consultar, use tuple.
tuple possui menos metodos, pois muitas funções da lista são para mudança de valores.



explicação do chatgpt:
Referência (apontando pro mesmo objeto)
list_1 = ['History', 'Math', 'Physics', 'CompSci']
list_2 = list_1  # apenas uma referência, não cria nova lista

list_1[0] = 'Art'

print("list_1:", list_1)
print("list_2:", list_2)
print("Mesmo objeto?", id(list_1) == id(list_2))

Saída:
list_1: ['Art', 'Math', 'Physics', 'CompSci']
list_2: ['Art', 'Math', 'Physics', 'CompSci']
Mesmo objeto? True


Cópia rasa (copy())(shallow copy)
list_1 = ['History', 'Math', 'Physics', 'CompSci']
list_2 = list_1.copy()  # cria uma nova lista

list_1[0] = 'Art'

print("list_1:", list_1)
print("list_2:", list_2)
print("Mesmo objeto?", id(list_1) == id(list_2))

Saída:
list_1: ['Art', 'Math', 'Physics', 'CompSci']
list_2: ['History', 'Math', 'Physics', 'CompSci']
Mesmo objeto? False


Diferença quando há listas dentro de listas
É aqui que a cópia rasa e a cópia profunda se diferenciam.
import copy

list_1 = [['History', 'Math'], ['Physics', 'CompSci']]

# cópia rasa
list_2 = list_1.copy()

# cópia profunda
list_3 = copy.deepcopy(list_1)

# alterando um elemento interno da lista original
list_1[0][0] = 'Art'

print("list_1:", list_1)
print("list_2 (shallow):", list_2)
print("list_3 (deep):", list_3)

Saída:
list_1: [['Art', 'Math'], ['Physics', 'CompSci']]
list_2 (shallow): [['Art', 'Math'], ['Physics', 'CompSci']]
list_3 (deep): [['History', 'Math'], ['Physics', 'CompSci']]

Perceba:
copy() (cópia rasa) ainda compartilha referências internas, por isso list_2 mudou junto.
deepcopy() cria objetos totalmente independentes, então list_3 ficou intacta.



sets são valores que são desordenados e não tem duplicas
cs_courses = {'History', 'Math', 'Physics', 'CompSci', 'Math'}

print(cs_courses)-> {'Math', 'Physics', 'History', 'CompSci'}
rodando denovo-> {'History', 'CompSci', 'Physics', 'Math'}

dá pra ver que são desordenados e não tem valores duplicados, na criação coloquei mais um Math, mas ele ignora pois está repetido
também ignora a ordem estabelecida na criação

é usado pra ver se um valor pertence a um conjunto (membership test) ('valor' in variavel)
, sets são muito mais eficientes nisso do que listas e tuples

outra ação que sets são otimizados para realizar é de checar que valores eles compartilham ou não com outros sets
para checar valores iguais usamos .intersection
cs_courses = {'History', 'Math', 'Physics', 'CompSci', 'Math'}
other_courses = {'Math', 'geography', 'physicalEd', 'portuguese'}

print(cs_courses.intersection(other_courses))-> {'Math'}

a diferença usamos .difference
print(cs_courses.difference(other_courses))-> {'Physics', 'History', 'CompSci'}

podemos combinar os valores dos dois sets usando .union
print(cs_courses.union(other_courses))-> {'CompSci', 'Physics', 'physicalEd', 'portuguese', 'Math', 'geography', 'History'}


Criação de listas, tuples e sets vazios
# Empty Lists
empty_list = []
empty_list = list()

# Empty Tuples
empty_tuple = ()
empty_tuple = tuple()

# Empty Sets
empty_set = {} # Não podemos usar assim. Isso não é um set vazio, é um dictionary vazio
empty_set = set()


# List comprehension
# É uma maneira mais compacta de criar uma lista em python. Ao invés de usar um loop e colocar a lista dentro fazendo append, a gente coloca esse loop dentro da lista pra criar ela.
# "List comprehensions in Python provide a concise way to create lists by embedding a loop and optional conditional logic in a single line." (https://realpython.com/list-comprehension-python/)

# ex de como seria feito sem a list comprehension
nums = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] # pra usar nos exemplos

# my_list = []

# for n in nums:
#     my_list.append(n)

# print(my_list)

#ex com o list comprehension
# my_list = [n for n in nums]

# print(my_list)


# outros exemplos
# lista com valores de n x n (numero ao quadrado)
# sem list comprehension
# my_list = []
# for n in nums:
#     my_list.append(n * n)
# print(my_list)

# com list comprehension
# my_list = [n*n for n in nums]
# print(my_list)

# com map + lambda (usando map e lambda a crição da lista fica em uma linha só mas a sua leitura não é facil como com a list comprehension, então é preferivel usar comprehension)
# my_list = map(lambda n: n*n, nums)
# print(list(my_list))

# n pra cada n in nuns se n for par
# sem list comprehension
# my_list = []

# for n in nums:
#     if n % 2 == 0:
#         my_list.append(n)
# print(my_list)

# com list comprehension
# my_list = [n for n in nums if n % 2 == 0]
# print(my_list)

# com filter + lambda (mesmo problema com o map + lambda, um iniciante não vai conseguir ler essa função, list comprehension é muito mais legivel)
# my_list = filter(lambda n: n % 2 ==0, nums)
# print(list(my_list))





dictionaries
https://www.w3schools.com/python/python_dictionaries.asp
dictionaries nos permitem trabalhar com pares de key:value

student = {'name': 'John', 'age': 25, 'courses': ['Math', 'CompSci']}

as chaves iniciam o dicionario. name é uma key, John é um value.
As outras "coisas" da variavel studant também são key:value
As keys acima são todas strings, mas elas podem ser qualquer dado imutavel
https://www.tutorialspoint.com/which-data-types-are-immutable-in-python

courses = ['history', 'math', 'phisics', 'compSci']

student = {'name': 'John', 'age': 25, 'courses': courses}
pode passar uma variavel lista como valor de uma key

chamar uma chave inexistente retorna um erro, pode não ser o que queremos, então pode-se usar o metodo get do dicionario
print(student.get('name'))-> John
print(student.get('phone'))-> None
assim ele retorna None ao invés de erro
se não quiser que volte o none podemos passar um segundo argumento no .get, que vai aparecer no lugar do none
print(student.get('name', 'No key found'))  -> John
print(student.get('phone', 'No key found')) -> No key found
aqui está voltando uma string, mas não precisa ser, pode ser outro tipo de valor, até mesmo uma variável
print(student.get('phone', courses)) -> ['history', 'math', 'phisics', 'compSci']


pode ser adicionada uma chave nova caso necessario
student['phone'] = '3625-3625'

print(student.get('phone', 'No key found')) -> 3625-3625


para mudar um valor podemos fazer 
student['name'] = 'Matt'
ou usar metodo .update, que é especialmente útil para atualizar varios valores de uma vez
.update recebe um dicionario como argumento, para mudar ou adicionar o que quer

student.update({'name': 'Lucas', 'age': '30', 'id': '1'})
print(student) -> {'name': 'Lucas', 'age': '30', 'courses': ['Math', 'CompSci'], 'phone': '3625-3625', 'id': '1'}


pra remover usamos del

del student['id']
print(student) -> {'name': 'Lucas', 'age': '30', 'courses': ['Math', 'CompSci'], 'phone': '3625-3625'}

ou usamos pop, que como observamos na lista, retorna o valor que foi retirado. Podendo ser armazenado em uma variavel
phone = student.pop('phone')
print(student) -> {'name': 'Lucas', 'age': '30', 'courses': ['Math', 'CompSci']}
print(phone) -> 3625-3625




print(len(student)) mostra o numero de chaves que nosso dicionario possui (-> 3)

print(student.keys()) mostra o nome das chaves que o dicionario possui (-> dict_keys(['name', 'age', 'courses']))

print(student.values()) mostra os valores do dicionario (-> dict_values(['Lucas', '30', ['Math', 'CompSci']]))

print(student.items()) mostra as keys:values do dicionario (-> dict_items([('name', 'Lucas'), ('age', '30'), ('courses', ['Math', 'CompSci'])]))


pra usar loop pra ver oque tem em um dicionario é preciso do .items se quisermos ver os valores também
só com student ele só mostra as keys
for key in student:
    print(key)
 -> name
	age
	courses


for key in student.items():
    print(key)
 -> ('name', 'Lucas')
	('age', '30')
	('courses', ['Math', 'CompSci'])    (curiosidade, esses valores são tuples, podemos ver com print(type(key)))

como o items vem em par de valores, usamos outra variavel para os valores também

for key, value in student.items():
    print(key, value)
 -> name Lucas
	age 30
	courses ['Math', 'CompSci']










# Comparisons:
# Equal:            ==
# Not Equal:        !=
# Greater Than:     >
# Less Than:        <
# Greater or Equal: >=
# Less or Equal:    <=
# Object Identity:  is (https://www.w3schools.com/python/ref_keyword_is.asp)
#                   \/
# The 'is' keyword is used to test if two variables refer to the same object.
# The test returns True if the two objects are the same object.
# The test returns False if they are not the same object, even if the two objects are 100% equal.
# Use the == operator to test if two variables are equal.

# language = "  PyTHON   "
language = "  JAva   "
# language = "C"


# if e elif
if language.lower().strip() == "python":
    print("Linguagem é python")
elif language.lower().strip() == "java":
    print("Linguagem é java")
else:
    print("Sem resultados")

pra comparar se um numero está entre um e outro podemos escrever assim: x<n<y

if n % 2 != 0:
    print('Weird')
elif 2 <= n <= 5:
    print('Not Weird')
elif 6 <= n <= 20:
    print('Weird')
elif n > 20:
    print('Not Weird')


# Python não possui switch case


# Além dessas comparações que coloquei acima, tamém temos operações booleanas que podemos usar
# Elas são: and (&&), or (||) e not (!)

user = 'admin'
logged_in = False

if user == 'admin' or logged_in:
    print('Página do Admin')
else:
    print('Acesso negado')

if user == 'admin' and not (not logged_in):
    print('Página do Admin')
else:
    print('Acesso negado')

# a = [1, 2, 3]
# b = [1, 2, 3]
# c = a
# print("a = [1, 2, 3]\nb = [1, 2, 3]\nc = a")
# print('')
# print('Teste com "b"')
# print(f"a == b : {a == b}")
# print(f"a is b : {a is b}")
# print(f"id 'a': {id(a)} \nid 'b': {id(b)}")
# print('')
# print('Teste com "c"')
# print(f"a == c : {a == c}")
# print(f"a is c : {a is c}")
# print(f"id 'a': {id(a)} \nid 'c': {id(c)}")

# a comparação com is funciona basicamente como id(variavel1) == id(variavel2)


# False Values:
    # False
    # None     (Python does not have a literal 'null' keyword. None é basicamente o null de python)
    # Zero of any numeric type
    # Any empty sequence. For example, '', (), [].
    # Any empty mapping. For example, {}.    
# (A mapping is a collection that allows you to look up a key and retrieve its value. https://realpython.com/python-mappings/
# https://docs.python.org/3/glossary.html#term-mapping)

# Todo resto é True

# condition = [""]

# if condition:
#     print('Evaluated to True')
# else:
#     print('Evaluated to False')

#exemplo de uso, preciso checar alguma função retornou uma string com valores
# string = ''

# if string:
#     print('String com algum valor')
# else:
#     print('String vazia')



# numbers = {1, 2, 3, 'x', 4, 5, 'teste', 'valor'}
#break e continue
# print(numbers)
# for number in numbers:
#     if number == 3:
#         print('achou o 3 e dá break')
#         break
#     print(number)
# print('')
# print(numbers)
# for number in numbers:
#     if number == 5:
#         print('achou o 5 e continua')
#         continue
#     print(number)


#for aninhado (nested)
# nums = [1, 2, 3]
# for num in nums:
#     for char in 'abc':
#         print(num, char)


#função range, basicamente vai repetir o loop o numero de vezes que passarmos. Começa do 0 e vai até o escolhido, mas não inclui ele (range(10) vai do 0 até 9)
# for i in range(10):
#     print(i)
#podemos alterar para começar em um número especifico se não quisermos que começe no 0
# for i in range(20, 31):
#     print(i)


x = 0

# while x < 10:
#     print(x)
#     x += 1

while True:
    if x == 5:
        break
    print(x)
    x += 1

# lembrando que python não tem do while, se precisar usar pode ser colocado um true na condição do while e depois arrumar a lógica nele para parar no momento certo

#Python não suporta incremento com ++ também...



Functions
# pra declarar funções usamos a palavra chave 'def', de define ou definition provavelmente
# pra criar uma função vazia usa-se 'pass', não pode deixar ela realmente vazia, pois gera erro
# def print_hello():
#     pass
# print_hello()
#-> chamar ela não resulta em nada pois dentro dela só tem o pass

#printar uma função sem o parênteses mostra uma "descrição" dela
# print(print_hello) 
#-> <function print_hello at 0x0000017F28951440>  (basicamente diz q é uma função, o seu nome e o lugar que ela está na memória, mas não executa ela, pra chamar ela precisa dos parênteses)

# def hello_world():
#     print('Hello, world!')

# hello_world() 
#-> Hello, world!
# Função serve basicamente pra reusar código em varias areas sem precisar escrever as mesmas linhas varias vezes, ajuda na manutenção também, pois só é necessário ajustar uma vez ao invés de ajustar em todas partes que iria repetir esse código
# não se repetir no geral é uma coisa boa, é um dos princípios da programação. "DRY" refere-se ao princípio de programação "Don't Repeat Yourself" (Não se repita)

# def return_hello():
#     return 'hello, world!'

# return_hello()
#-> não gera nada pois ela só retorna uma string, a gente precisa fazer algo com isso se quiser algum resultado
# print(return_hello().title().removesuffix('!'))
#-> Hello, World
#como o retorno é string, podemos usar metodos de string nela pra manipular seu resultado

# função com parametro
# def hello_name(nome):
    # a variável 'nome' só interfere dentro dassa função, o escopo dela é essa função. Se em outra parte do código existir uma variável com o mesmo nome, elas não interferem uma com a outra
    #(Python Tutorial: Variable Scope : https://www.youtube.com/watch?v=QVdf0LgmICw)

    # return 'Hello, {}'.format(nome)
#     return f'Hello, {nome.title()}'

# print(hello_name('matheus'))
# chamar essa função sem passar um argumento gera erro, para não gerar precisamos de um valor padrão

# def hello_name2(nome = '"estranho"'):
#     return f'Ola, {nome}'
# print(hello_name2().title())
# print(hello_name2('maTHeuS').title())

# def hello_name3(cumprimento = "Ola", nome = '"estranho"'):
#     return f'{cumprimento}, {nome}'
# print(hello_name3().title())
# print(hello_name3('oI', 'maTHeuS').title())


# *args **kwargs
#    *args: Non-keyword (positional) arguments
#    **kwargs: Keyword arguments
# https://www.geeksforgeeks.org/python/args-kwargs-python/

# def student_info(*args, **kwargs):
#     print(args)
#     print(kwargs)

# student_info('math', 'art', name = 'john', age=22)
#-> ('math', 'art')   (tuple)
#   {'name': 'john', 'age': 22}   (dictionary)

# courses = ['math', 'art']
# info = {'name' : 'john', 'age':22}

# student_info(courses, info)
#-> (['math', 'art'], {'name': 'john', 'age': 22})
#   {}
# não funcionou de forma correta, passou tudo no args e nada no kwargs. A forma correta de chamar seria 
# student_info(*courses, **info)
#-> ('math', 'art')
#   {'name': 'john', 'age': 22}


# Number of days per month. First value placeholder for indexing purposes.
month_days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]


def is_leap(year):
    """Return True for leap years, False for non-leap years."""
    #  /\ é uma docstring, usada para documentar a funcionalidade de funções, metodos e classes
    # https://www.geeksforgeeks.org/python/python-docstrings/
    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)


def days_in_month(year, month):
    """Return number of days in that month in that year."""

    if not 1 <= month <= 12:
        return 'Invalid Month'

    if month == 2 and is_leap(year):
        return 29

    return month_days[month]

print(is_leap(2016))

print(days_in_month(2016, 2))





# pra importar o modulo, e apelidar de fm (apelido é opcional mas útil)
import first_module as fm

courses = ['history', 'math', 'physics', 'compsci']

index = fm.find_index(courses, 'physics')
# pra usar uma função de um modulo importado precisamos digitar o nome do modulo primeiro e depois o que queremos usar daquele modulo
# print(index) # -> 2 (passando 'physics' no argumento)

# print(fm.test)
# a variavel teste também é importada, e igual a função, ela precisa ser chamada referenciando o modulo

# ficar referenciando o nome do modulo pode ficar meio comprido dependendo do nome, então podemos dar um apelido escrevendo na frente da importação (de import first_module -> import first_module as fm) parece com o apelido das tabelas em sql
#assim podemos usar somente fm para referenciar ele (index = fm.find_index(courses, 'physics'))

# pra importar a função
from first_module import find_index as fi, test #as t
# importando a função não é necessario referenciar de onde ela veio
# mas só da acesso a essa função e o que você importar nada mais do modulo
# também podemos apelidar a função da mesma maneira que apelidamos o modulo
# de maneira geral é bom deixar o nome da variavel de uma maneira facil de ler, 'fi' não facilita a leitura então pode não ser a melhor opção
 
# index = find_index(courses, 'compsci')
index = fi(courses, 'compsci')
# print(index)

# from first_module import *
# importa tudo do modulo. Não é visto como uma boa prática por vários motivos como poluir seu namespace, pode ficar difícil saber de onde vem uma função especifica, risco de sobreescrever uma variavel/função e etc
# https://www.geeksforgeeks.org/python/why-import-star-in-python-is-a-bad-idea/


# como o python sabe como encontrar o modulo first_module?
# quando a gente importa um módulo ele checa alguns lugares, podemos saber quais lugares importando 'sys' e vendo o .path
#import sys

#print(sys.path)
# ['c:\\estudoPython',
#  'C:\\Users\\Mathe\\AppData\\Local\\Programs\\Python\\Python313\\python313.zip',
#  'C:\\Users\\Mathe\\AppData\\Local\\Programs\\Python\\Python313\\DLLs',
#  'C:\\Users\\Mathe\\AppData\\Local\\Programs\\Python\\Python313\\Lib',
#  'C:\\Users\\Mathe\\AppData\\Local\\Programs\\Python\\Python313',
#  'C:\\Users\\Mathe\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages']

# esses são os lugares que o python olha pra procurar o modulo quando eu importo eles
#quais diretórios são adicionados nessa lista? primeiro é o local do arquivo que estamos rodando, depois ele adiciona os diretoris listados na variável de ambiente PYTHONPATH, depois os diretórios de biblioteca padrões (por isso podemos adicionar os modulos padrões) e por ultimo olha no diretório de pacotes de site por pacotes de terceiros
# (https://www.geeksforgeeks.org/python/sys-path-in-python/)

# ao esconder o arquivo first_module.py em uma pasta na area de trabalho e rodar o código, recebemos esse erro
# Traceback (most recent call last):
#   File "c:\estudoPython\intro4.py", line 2, in <module>
#     import first_module as fm
# ModuleNotFoundError: No module named 'first_module'

# Tem algumas coisas que podemos fazer para lidar com isso
# Nós podemos adicionar o diretório no nosso sys.path com append
# sys.path.append('C:\\Users\\Mathe\\OneDrive\\Desktop\\teste')

# não é a melhor solução, é preferivel mudar na variável de ambiente PYTHONPATH 
# pra ver como siga esse video https://www.youtube.com/watch?v=CqvZ3vGoGs0&list=PL-osiE80TeTskrapNbzXhwoFUiLCjGgY7&index=11&t=702s


# usar módulos das bibilioteca padrão é uma boa ideia, afinal não tem porque reinventar a roda, aqueles modulos são usados e aprovados a anos. Não tem problema tentar escrever um código seu, mas para resolver um problema que já tem a resposta é sempre bom usar o recurso disponível

um exemplo para gerar um valor randomico

import random

random_course = random.choice(courses)

print(random_course) #-> imprime um valor randomico da variavel courses

outros exemplos de modulos interessantes.

import math

rads = math.radians(90)

print(rads)
print(math.sin(rads))

import datetime, calendar

today = datetime.datetime.today()
print(today)

print(calendar.isleap(2020))

import os
# https://docs.python.org/pt-br/3.13/library/os.html

print(os.getcwd())#-> C:\estudoPython (getcwd == get current working diretory)


# essas bibliotecas padrões são arquivos python, pra ver a sua localização no pc podemos usar '.__file__'
# isso é o 'dunder file', dunder é o underscore duplo
print(os.__file__)
print(random.__file__)
print(fm.__file__)





